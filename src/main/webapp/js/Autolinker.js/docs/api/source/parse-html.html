<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">&quot;use strict&quot;;
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
var tslib_1 = require(&quot;tslib&quot;);
var regex_lib_1 = require(&quot;../regex-lib&quot;);
var utils_1 = require(&quot;../utils&quot;);
// For debugging: search for other &quot;For debugging&quot; lines
// import CliTable from &#39;cli-table&#39;;
<span id='global-method-parseHtml'>/**
</span> * Parses an HTML string, calling the callbacks to notify of tags and text.
 *
 * ## History
 *
 * This file previously used a regular expression to find html tags in the input
 * text. Unfortunately, we ran into a bunch of catastrophic backtracking issues
 * with certain input text, causing Autolinker to either hang or just take a
 * really long time to parse the string.
 *
 * The current code is intended to be a O(n) algorithm that walks through
 * the string in one pass, and tries to be as cheap as possible. We don&#39;t need
 * to implement the full HTML spec, but rather simply determine where the string
 * looks like an HTML tag, and where it looks like text (so that we can autolink
 * that).
 *
 * This state machine parser is intended just to be a simple but performant
 * parser of HTML for the subset of requirements we have. We simply need to:
 *
 * 1. Determine where HTML tags are
 * 2. Determine the tag name (Autolinker specifically only cares about &lt;a&gt;,
 *    &lt;script&gt;, and &lt;style&gt; tags, so as not to link any text within them)
 *
 * We don&#39;t need to:
 *
 * 1. Create a parse tree
 * 2. Auto-close tags with invalid markup
 * 3. etc.
 *
 * The other intention behind this is that we didn&#39;t want to add external
 * dependencies on the Autolinker utility which would increase its size. For
 * instance, adding htmlparser2 adds 125kb to the minified output file,
 * increasing its final size from 47kb to 172kb (at the time of writing). It
 * also doesn&#39;t work exactly correctly, treating the string &quot;&lt;3 blah blah blah&quot;
 * as an HTML tag.
 *
 * Reference for HTML spec:
 *
 *     https://www.w3.org/TR/html51/syntax.html#sec-tokenization
 *
 * @param {String} html The HTML to parse
 * @param {Object} callbacks
 * @param {Function} callbacks.onOpenTag Callback function to call when an open
 *   tag is parsed. Called with the tagName as its argument.
 * @param {Function} callbacks.onCloseTag Callback function to call when a close
 *   tag is parsed. Called with the tagName as its argument. If a self-closing
 *   tag is found, `onCloseTag` is called immediately after `onOpenTag`.
 * @param {Function} callbacks.onText Callback function to call when text (i.e
 *   not an HTML tag) is parsed. Called with the text (string) as its first
 *   argument, and offset (number) into the string as its second.
 */
function parseHtml(html, _a) {
    var onOpenTag = _a.onOpenTag, onCloseTag = _a.onCloseTag, onText = _a.onText, onComment = _a.onComment, onDoctype = _a.onDoctype;
    var noCurrentTag = new CurrentTag();
    var charIdx = 0, len = html.length, state = 0 /* Data */, currentDataIdx = 0, // where the current data start index is
    currentTag = noCurrentTag; // describes the current tag that is being read
    // For debugging: search for other &quot;For debugging&quot; lines
    // const table = new CliTable( {
    // 	head: [ &#39;charIdx&#39;, &#39;char&#39;, &#39;state&#39;, &#39;currentDataIdx&#39;, &#39;currentOpenTagIdx&#39;, &#39;tag.type&#39; ]
    // } );
    while (charIdx &lt; len) {
        var char = html.charAt(charIdx);
        // For debugging: search for other &quot;For debugging&quot; lines
        // ALSO: Temporarily remove the &#39;const&#39; keyword on the State enum
        // table.push( 
        // 	[ charIdx, char, State[ state ], currentDataIdx, currentTag.idx, currentTag.idx === -1 ? &#39;&#39; : currentTag.type ] 
        // );
        switch (state) {
            case 0 /* Data */:
                stateData(char);
                break;
            case 1 /* TagOpen */:
                stateTagOpen(char);
                break;
            case 2 /* EndTagOpen */:
                stateEndTagOpen(char);
                break;
            case 3 /* TagName */:
                stateTagName(char);
                break;
            case 4 /* BeforeAttributeName */:
                stateBeforeAttributeName(char);
                break;
            case 5 /* AttributeName */:
                stateAttributeName(char);
                break;
            case 6 /* AfterAttributeName */:
                stateAfterAttributeName(char);
                break;
            case 7 /* BeforeAttributeValue */:
                stateBeforeAttributeValue(char);
                break;
            case 8 /* AttributeValueDoubleQuoted */:
                stateAttributeValueDoubleQuoted(char);
                break;
            case 9 /* AttributeValueSingleQuoted */:
                stateAttributeValueSingleQuoted(char);
                break;
            case 10 /* AttributeValueUnquoted */:
                stateAttributeValueUnquoted(char);
                break;
            case 11 /* AfterAttributeValueQuoted */:
                stateAfterAttributeValueQuoted(char);
                break;
            case 12 /* SelfClosingStartTag */:
                stateSelfClosingStartTag(char);
                break;
            case 13 /* MarkupDeclarationOpenState */:
                stateMarkupDeclarationOpen(char);
                break;
            case 14 /* CommentStart */:
                stateCommentStart(char);
                break;
            case 15 /* CommentStartDash */:
                stateCommentStartDash(char);
                break;
            case 16 /* Comment */:
                stateComment(char);
                break;
            case 17 /* CommentEndDash */:
                stateCommentEndDash(char);
                break;
            case 18 /* CommentEnd */:
                stateCommentEnd(char);
                break;
            case 19 /* CommentEndBang */:
                stateCommentEndBang(char);
                break;
            case 20 /* Doctype */:
                stateDoctype(char);
                break;
            default:
                utils_1.throwUnhandledCaseError(state);
        }
        // For debugging: search for other &quot;For debugging&quot; lines
        // ALSO: Temporarily remove the &#39;const&#39; keyword on the State enum
        // table.push( 
        // 	[ charIdx, char, State[ state ], currentDataIdx, currentTag.idx, currentTag.idx === -1 ? &#39;&#39; : currentTag.type ] 
        // );
        charIdx++;
    }
    if (currentDataIdx &lt; charIdx) {
        emitText();
    }
    // For debugging: search for other &quot;For debugging&quot; lines
    // console.log( &#39;\n&#39; + table.toString() );
    // Called when non-tags are being read (i.e. the text around HTML â€ ags)
    // https://www.w3.org/TR/html51/syntax.html#data-state
    function stateData(char) {
        if (char === &#39;&lt;&#39;) {
            startNewTag();
        }
    }
    // Called after a &#39;&lt;&#39; is read from the Data state
    // https://www.w3.org/TR/html51/syntax.html#tag-open-state
    function stateTagOpen(char) {
        if (char === &#39;!&#39;) {
            state = 13 /* MarkupDeclarationOpenState */;
        }
        else if (char === &#39;/&#39;) {
            state = 2 /* EndTagOpen */;
            currentTag = new CurrentTag(tslib_1.__assign({}, currentTag, { isClosing: true }));
        }
        else if (char === &#39;&lt;&#39;) {
            // start of another tag (ignore the previous, incomplete one)
            startNewTag();
        }
        else if (regex_lib_1.letterRe.test(char)) {
            // tag name start (and no &#39;/&#39; read)
            state = 3 /* TagName */;
            currentTag = new CurrentTag(tslib_1.__assign({}, currentTag, { isOpening: true }));
        }
        else {
            // Any other 
            state = 0 /* Data */;
            currentTag = noCurrentTag;
        }
    }
    // After a &#39;&lt;x&#39;, &#39;&lt;/x&#39; sequence is read (where &#39;x&#39; is a letter character), 
    // this is to continue reading the tag name
    // https://www.w3.org/TR/html51/syntax.html#tag-name-state
    function stateTagName(char) {
        if (regex_lib_1.whitespaceRe.test(char)) {
            currentTag = new CurrentTag(tslib_1.__assign({}, currentTag, { name: captureTagName() }));
            state = 4 /* BeforeAttributeName */;
        }
        else if (char === &#39;&lt;&#39;) {
            // start of another tag (ignore the previous, incomplete one)
            startNewTag();
        }
        else if (char === &#39;/&#39;) {
            currentTag = new CurrentTag(tslib_1.__assign({}, currentTag, { name: captureTagName() }));
            state = 12 /* SelfClosingStartTag */;
        }
        else if (char === &#39;&gt;&#39;) {
            currentTag = new CurrentTag(tslib_1.__assign({}, currentTag, { name: captureTagName() }));
            emitTagAndPreviousTextNode(); // resets to Data state as well
        }
        else if (!regex_lib_1.letterRe.test(char) &amp;&amp; !regex_lib_1.digitRe.test(char) &amp;&amp; char !== &#39;:&#39;) {
            // Anything else that does not form an html tag. Note: the colon 
            // character is accepted for XML namespaced tags
            resetToDataState();
        }
        else {
            // continue reading tag name
        }
    }
    // Called after the &#39;/&#39; is read from a &#39;&lt;/&#39; sequence
    // https://www.w3.org/TR/html51/syntax.html#end-tag-open-state
    function stateEndTagOpen(char) {
        if (char === &#39;&gt;&#39;) { // parse error. Encountered &quot;&lt;/&gt;&quot;. Skip it without treating as a tag
            resetToDataState();
        }
        else if (regex_lib_1.letterRe.test(char)) {
            state = 3 /* TagName */;
        }
        else {
            // some other non-tag-like character, don&#39;t treat this as a tag
            resetToDataState();
        }
    }
    // https://www.w3.org/TR/html51/syntax.html#before-attribute-name-state
    function stateBeforeAttributeName(char) {
        if (regex_lib_1.whitespaceRe.test(char)) {
            // stay in BeforeAttributeName state - continue reading chars
        }
        else if (char === &#39;/&#39;) {
            state = 12 /* SelfClosingStartTag */;
        }
        else if (char === &#39;&gt;&#39;) {
            emitTagAndPreviousTextNode(); // resets to Data state as well
        }
        else if (char === &#39;&lt;&#39;) {
            // start of another tag (ignore the previous, incomplete one)
            startNewTag();
        }
        else if (char === &quot;=&quot; || regex_lib_1.quoteRe.test(char) || regex_lib_1.controlCharsRe.test(char)) {
            // &quot;Parse error&quot; characters that, according to the spec, should be
            // appended to the attribute name, but we&#39;ll treat these characters
            // as not forming a real HTML tag
            resetToDataState();
        }
        else {
            // Any other char, start of a new attribute name
            state = 5 /* AttributeName */;
        }
    }
    // https://www.w3.org/TR/html51/syntax.html#attribute-name-state
    function stateAttributeName(char) {
        if (regex_lib_1.whitespaceRe.test(char)) {
            state = 6 /* AfterAttributeName */;
        }
        else if (char === &#39;/&#39;) {
            state = 12 /* SelfClosingStartTag */;
        }
        else if (char === &#39;=&#39;) {
            state = 7 /* BeforeAttributeValue */;
        }
        else if (char === &#39;&gt;&#39;) {
            emitTagAndPreviousTextNode(); // resets to Data state as well
        }
        else if (char === &#39;&lt;&#39;) {
            // start of another tag (ignore the previous, incomplete one)
            startNewTag();
        }
        else if (regex_lib_1.quoteRe.test(char)) {
            // &quot;Parse error&quot; characters that, according to the spec, should be
            // appended to the attribute name, but we&#39;ll treat these characters
            // as not forming a real HTML tag
            resetToDataState();
        }
        else {
            // anything else: continue reading attribute name
        }
    }
    // https://www.w3.org/TR/html51/syntax.html#after-attribute-name-state
    function stateAfterAttributeName(char) {
        if (regex_lib_1.whitespaceRe.test(char)) {
            // ignore the character - continue reading
        }
        else if (char === &#39;/&#39;) {
            state = 12 /* SelfClosingStartTag */;
        }
        else if (char === &#39;=&#39;) {
            state = 7 /* BeforeAttributeValue */;
        }
        else if (char === &#39;&gt;&#39;) {
            emitTagAndPreviousTextNode();
        }
        else if (char === &#39;&lt;&#39;) {
            // start of another tag (ignore the previous, incomplete one)
            startNewTag();
        }
        else if (regex_lib_1.quoteRe.test(char)) {
            // &quot;Parse error&quot; characters that, according to the spec, should be
            // appended to the attribute name, but we&#39;ll treat these characters
            // as not forming a real HTML tag
            resetToDataState();
        }
        else {
            // Any other character, start a new attribute in the current tag
            state = 5 /* AttributeName */;
        }
    }
    // https://www.w3.org/TR/html51/syntax.html#before-attribute-value-state
    function stateBeforeAttributeValue(char) {
        if (regex_lib_1.whitespaceRe.test(char)) {
            // ignore the character - continue reading
        }
        else if (char === &quot;\&quot;&quot;) {
            state = 8 /* AttributeValueDoubleQuoted */;
        }
        else if (char === &quot;&#39;&quot;) {
            state = 9 /* AttributeValueSingleQuoted */;
        }
        else if (/[&gt;=`]/.test(char)) {
            // Invalid chars after an &#39;=&#39; for an attribute value, don&#39;t count 
            // the current tag as an HTML tag
            resetToDataState();
        }
        else if (char === &#39;&lt;&#39;) {
            // start of another tag (ignore the previous, incomplete one)
            startNewTag();
        }
        else {
            // Any other character, consider it an unquoted attribute value
            state = 10 /* AttributeValueUnquoted */;
        }
    }
    // https://www.w3.org/TR/html51/syntax.html#attribute-value-double-quoted-state
    function stateAttributeValueDoubleQuoted(char) {
        if (char === &quot;\&quot;&quot;) { // end the current double-quoted attribute
            state = 11 /* AfterAttributeValueQuoted */;
        }
        else {
            // consume the character as part of the double-quoted attribute value
        }
    }
    // https://www.w3.org/TR/html51/syntax.html#attribute-value-single-quoted-state
    function stateAttributeValueSingleQuoted(char) {
        if (char === &quot;&#39;&quot;) { // end the current single-quoted attribute
            state = 11 /* AfterAttributeValueQuoted */;
        }
        else {
            // consume the character as part of the double-quoted attribute value
        }
    }
    // https://www.w3.org/TR/html51/syntax.html#attribute-value-unquoted-state
    function stateAttributeValueUnquoted(char) {
        if (regex_lib_1.whitespaceRe.test(char)) {
            state = 4 /* BeforeAttributeName */;
        }
        else if (char === &#39;&gt;&#39;) {
            emitTagAndPreviousTextNode();
        }
        else if (char === &#39;&lt;&#39;) {
            // start of another tag (ignore the previous, incomplete one)
            startNewTag();
        }
        else {
            // Any other character, treat it as part of the attribute value
        }
    }
    // https://www.w3.org/TR/html51/syntax.html#after-attribute-value-quoted-state
    function stateAfterAttributeValueQuoted(char) {
        if (regex_lib_1.whitespaceRe.test(char)) {
            state = 4 /* BeforeAttributeName */;
        }
        else if (char === &#39;/&#39;) {
            state = 12 /* SelfClosingStartTag */;
        }
        else if (char === &#39;&gt;&#39;) {
            emitTagAndPreviousTextNode();
        }
        else if (char === &#39;&lt;&#39;) {
            // start of another tag (ignore the previous, incomplete one)
            startNewTag();
        }
        else {
            // Any other character, &quot;parse error&quot;. Spec says to switch to the
            // BeforeAttributeState and re-consume the character, as it may be
            // the start of a new attribute name
            state = 4 /* BeforeAttributeName */;
            reconsumeCurrentCharacter();
        }
    }
    // A &#39;/&#39; has just been read in the current tag (presumably for &#39;/&gt;&#39;), and 
    // this handles the next character
    // https://www.w3.org/TR/html51/syntax.html#self-closing-start-tag-state
    function stateSelfClosingStartTag(char) {
        if (char === &#39;&gt;&#39;) {
            currentTag = new CurrentTag(tslib_1.__assign({}, currentTag, { isClosing: true }));
            emitTagAndPreviousTextNode(); // resets to Data state as well
        }
        else {
            state = 4 /* BeforeAttributeName */;
        }
    }
    // https://www.w3.org/TR/html51/syntax.html#markup-declaration-open-state
    // (HTML Comments or !DOCTYPE)
    function stateMarkupDeclarationOpen(char) {
        if (html.substr(charIdx, 2) === &#39;--&#39;) { // html comment
            charIdx += 2; // &quot;consume&quot; characters
            currentTag = new CurrentTag(tslib_1.__assign({}, currentTag, { type: &#39;comment&#39; }));
            state = 14 /* CommentStart */;
        }
        else if (html.substr(charIdx, 7).toUpperCase() === &#39;DOCTYPE&#39;) {
            charIdx += 7; // &quot;consume&quot; characters
            currentTag = new CurrentTag(tslib_1.__assign({}, currentTag, { type: &#39;doctype&#39; }));
            state = 20 /* Doctype */;
        }
        else {
            // At this point, the spec specifies that the state machine should
            // enter the &quot;bogus comment&quot; state, in which case any character(s) 
            // after the &#39;&lt;!&#39; that were read should become an HTML comment up
            // until the first &#39;&gt;&#39; that is read (or EOF). Instead, we&#39;ll assume
            // that a user just typed &#39;&lt;!&#39; as part of text data
            resetToDataState();
        }
    }
    // Handles after the sequence &#39;&lt;!--&#39; has been read
    // https://www.w3.org/TR/html51/syntax.html#comment-start-state
    function stateCommentStart(char) {
        if (char === &#39;-&#39;) {
            // We&#39;ve read the sequence &#39;&lt;!---&#39; at this point (3 dashes)
            state = 15 /* CommentStartDash */;
        }
        else if (char === &#39;&gt;&#39;) {
            // At this point, we&#39;ll assume the comment wasn&#39;t a real comment
            // so we&#39;ll just emit it as data. We basically read the sequence 
            // &#39;&lt;!--&gt;&#39;
            resetToDataState();
        }
        else {
            // Any other char, take it as part of the comment
            state = 16 /* Comment */;
        }
    }
    // We&#39;ve read the sequence &#39;&lt;!---&#39; at this point (3 dashes)
    // https://www.w3.org/TR/html51/syntax.html#comment-start-dash-state
    function stateCommentStartDash(char) {
        if (char === &#39;-&#39;) {
            // We&#39;ve read &#39;&lt;!----&#39; (4 dashes) at this point
            state = 18 /* CommentEnd */;
        }
        else if (char === &#39;&gt;&#39;) {
            // At this point, we&#39;ll assume the comment wasn&#39;t a real comment
            // so we&#39;ll just emit it as data. We basically read the sequence 
            // &#39;&lt;!---&gt;&#39;
            resetToDataState();
        }
        else {
            // Anything else, take it as a valid comment
            state = 16 /* Comment */;
        }
    }
    // Currently reading the comment&#39;s text (data)
    // https://www.w3.org/TR/html51/syntax.html#comment-state
    function stateComment(char) {
        if (char === &#39;-&#39;) {
            state = 17 /* CommentEndDash */;
        }
        else {
            // Any other character, stay in the Comment state
        }
    }
    // When we we&#39;ve read the first dash inside a comment, it may signal the
    // end of the comment if we read another dash
    // https://www.w3.org/TR/html51/syntax.html#comment-end-dash-state
    function stateCommentEndDash(char) {
        if (char === &#39;-&#39;) {
            state = 18 /* CommentEnd */;
        }
        else {
            // Wasn&#39;t a dash, must still be part of the comment
            state = 16 /* Comment */;
        }
    }
    // After we&#39;ve read two dashes inside a comment, it may signal the end of 
    // the comment if we then read a &#39;&gt;&#39; char
    // https://www.w3.org/TR/html51/syntax.html#comment-end-state
    function stateCommentEnd(char) {
        if (char === &#39;&gt;&#39;) {
            emitTagAndPreviousTextNode();
        }
        else if (char === &#39;!&#39;) {
            state = 19 /* CommentEndBang */;
        }
        else if (char === &#39;-&#39;) {
            // A 3rd &#39;-&#39; has been read: stay in the CommentEnd state
        }
        else {
            // Anything else, switch back to the comment state since we didn&#39;t
            // read the full &quot;end comment&quot; sequence (i.e. &#39;--&gt;&#39;)
            state = 16 /* Comment */;
        }
    }
    // We&#39;ve read the sequence &#39;--!&#39; inside of a comment
    // https://www.w3.org/TR/html51/syntax.html#comment-end-bang-state
    function stateCommentEndBang(char) {
        if (char === &#39;-&#39;) {
            // We read the sequence &#39;--!-&#39; inside of a comment. The last dash
            // could signify that the comment is going to close
            state = 17 /* CommentEndDash */;
        }
        else if (char === &#39;&gt;&#39;) {
            // End of comment with the sequence &#39;--!&gt;&#39;
            emitTagAndPreviousTextNode();
        }
        else {
            // The &#39;--!&#39; was not followed by a &#39;&gt;&#39;, continue reading the 
            // comment&#39;s text
            state = 16 /* Comment */;
        }
    }
<span id='global-method-stateDoctype'>    /**
</span>     * For DOCTYPES in particular, we don&#39;t care about the attributes. Just
     * advance to the &#39;&gt;&#39; character and emit the tag, unless we find a &#39;&lt;&#39;
     * character in which case we&#39;ll start a new tag.
     *
     * Example doctype tag:
     *    &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;
     *
     * Actual spec: https://www.w3.org/TR/html51/syntax.html#doctype-state
     */
    function stateDoctype(char) {
        if (char === &#39;&gt;&#39;) {
            emitTagAndPreviousTextNode();
        }
        else if (char === &#39;&lt;&#39;) {
            startNewTag();
        }
        else {
            // stay in the Doctype state
        }
    }
<span id='global-method-resetToDataState'>    /**
</span>     * Resets the state back to the Data state, and removes the current tag.
     *
     * We&#39;ll generally run this function whenever a &quot;parse error&quot; is
     * encountered, where the current tag that is being read no longer looks
     * like a real HTML tag.
     */
    function resetToDataState() {
        state = 0 /* Data */;
        currentTag = noCurrentTag;
    }
<span id='global-method-startNewTag'>    /**
</span>     * Starts a new HTML tag at the current index, ignoring any previous HTML
     * tag that was being read.
     *
     * We&#39;ll generally run this function whenever we read a new &#39;&lt;&#39; character,
     * including when we read a &#39;&lt;&#39; character inside of an HTML tag that we were
     * previously reading.
     */
    function startNewTag() {
        state = 1 /* TagOpen */;
        currentTag = new CurrentTag({ idx: charIdx });
    }
<span id='global-method-emitTagAndPreviousTextNode'>    /**
</span>     * Once we&#39;ve decided to emit an open tag, that means we can also emit the
     * text node before it.
     */
    function emitTagAndPreviousTextNode() {
        var textBeforeTag = html.slice(currentDataIdx, currentTag.idx);
        if (textBeforeTag) {
            // the html tag was the first element in the html string, or two 
            // tags next to each other, in which case we should not emit a text 
            // node
            onText(textBeforeTag, currentDataIdx);
        }
        if (currentTag.type === &#39;comment&#39;) {
            onComment(currentTag.idx);
        }
        else if (currentTag.type === &#39;doctype&#39;) {
            onDoctype(currentTag.idx);
        }
        else {
            if (currentTag.isOpening) {
                onOpenTag(currentTag.name, currentTag.idx);
            }
            if (currentTag.isClosing) { // note: self-closing tags will emit both opening and closing
                onCloseTag(currentTag.name, currentTag.idx);
            }
        }
        // Since we just emitted a tag, reset to the data state for the next char
        resetToDataState();
        currentDataIdx = charIdx + 1;
    }
    function emitText() {
        var text = html.slice(currentDataIdx, charIdx);
        onText(text, currentDataIdx);
        currentDataIdx = charIdx + 1;
    }
<span id='global-method-captureTagName'>    /**
</span>     * Captures the tag name from the start of the tag to the current character
     * index, and converts it to lower case
     */
    function captureTagName() {
        var startIdx = currentTag.idx + (currentTag.isClosing ? 2 : 1);
        return html.slice(startIdx, charIdx).toLowerCase();
    }
<span id='global-method-reconsumeCurrentCharacter'>    /**
</span>     * Causes the main loop to re-consume the current character, such as after
     * encountering a &quot;parse error&quot; that changed state and needs to reconsume
     * the same character in that new state.
     */
    function reconsumeCurrentCharacter() {
        charIdx--;
    }
}
exports.parseHtml = parseHtml;
var CurrentTag =  (function () {
    function CurrentTag(cfg) {
        if (cfg === void 0) { cfg = {}; }
        this.idx = cfg.idx !== undefined ? cfg.idx : -1;
        this.type = cfg.type || &#39;tag&#39;;
        this.name = cfg.name || &#39;&#39;;
        this.isOpening = !!cfg.isOpening;
        this.isClosing = !!cfg.isClosing;
    }
    return CurrentTag;
}());

//# sourceMappingURL=parse-html.js.map
</pre>
</body>
</html>
